/* ~marcus *//* */let showLabels, showBackground, showPreviewImage;showBackground = true;showLabels = true;showPreviewImage = true;let areLabelsShowing = true;let mBrdContainer, mBrdScene,    mBrdCamera, mBrdRenderer,    mBrdControl, mBrdMaterial,    mStimControl, mSkyBoxMaterial, mDragControls,    BoardCoverColor, mBrdColor, mBrdTintMesh,    mBrdMesh, mBrdBackupMesh, mBrdTintMaterial;let mCurrentBrdTintStrength = 0.5;let rederingImage = false; //Not sure if we will need this, But i've copied it over just incase...let useHttpsImage = false; //False for debug//constants for  auto stim placement for previewlet Y_OFFSET = 5;let X_OFFSET = 5;let MAX_STIMS_IN_ROW = 5; //Five per. Affects preview rows in addStimsToBoardlet lockBoard = true; //Keep board from being interacted with. Disables the board controls.//the currently loaded board model object.let renderedBoard = null;//Id maps, used in the render functions to track state of each item  being rendered...let stimsOnBoard = {};let stimUuids = {};//Stores a mapping of stimIds to stim sprite label UUIDs to use in filtering stimslet stimsWithLabelOnBoard = {};//Drag control object holderslet objects = [];/*    A stim should be a scene containing the render of the stim and the label    Idk what the last group was going for. */let objectOnBoard = [];let objectPosition = [];//DEP_onDebug();//lol I don't think withBoard is the best here, yes I know. I'll fix it later.//todo: fix this naming/**    Call this first!    This inits the board and the camera, scene, and skybox.    Also sets up the drag controls.    @param previewMode -if true, locks down the scene by default. No need to pass with locks.    @param withLocks - {        'lockAll| lockZoom | lockRotate| lockTilt': true | null,        '    } @param withConstraints - {        shouldHidePreview [bool], shouldHideStimLabels [bool], shouldHideBgImage [bool] } due to some funkyness in THREE.JS, lock zoom currently does not work. todo: find a fix for lockZoom */function initExperimentScene(previewMode = false,withLocks = null, withConstraints = null){    //Setup the base mesh here      // SCENE    mBrdScene = new THREE.Scene();    //todo: Maybe this should check for undefined as well?    if(withConstraints){        showPreviewImage = withConstraints.shouldHidePreview !== null ? !withConstraints.shouldHidePreview : false;        showLabels = withConstraints.shouldHideStimLabels !== null ? !withConstraints.shouldHideStimLabels : false;        showBackground = withConstraints.shouldHideBgImage !== null ? !withConstraints.shouldHideBgImage : false;    }    // CAMERA    var SCREEN_WIDTH = 500, SCREEN_HEIGHT = 500;    var VIEW_ANGLE = 5, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;    mBrdCamera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);    mBrdScene.add(mBrdCamera);    //Set the camera's z so that it's a decent distance away.    mBrdCamera.position.set(0, 0, 400); //My guess is that changing the 400 will change the field of view    //Point our camera at the board    mBrdCamera.lookAt(mBrdScene.position);    // RENDERER Attach it here    if (Detector.webgl) {        mBrdRenderer = new THREE.WebGLRenderer({antialias: true, preserveDrawingBuffer: true});    } else {        mBrdRenderer = new THREE.CanvasRenderer();    }    mBrdRenderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);    mBrdContainer = document.getElementById('previewRenderArea');    mBrdContainer.appendChild(mBrdRenderer.domElement);    // Create board controlls    mBrdControl = new THREE.OrbitControls(mBrdCamera, mBrdRenderer.domElement);    mDragControls = new THREE.DragControls(objects, mBrdCamera, mBrdRenderer.domElement);    mDragControls.addEventListener('dragstart', function (event) {        //Keep the board from moving while the user is dragging        mBrdControl.enabled = false;        console.debug(`Drag start for ${event.object.name}`);        _clearLabelFromStim(event.object.name);        //Remove label belonging to this stim. Since it will have the same name, you also need to check the uuid        //Ensure that you're updating the stored UUID everytime that stim label get's rerenders to a new location    });    mDragControls.addEventListener('dragend', function (event) {        mBrdControl.enabled = true;        if(!event.object.name){            console.warn('Dragended but the object had no name?????');            return;        }        let stimId = event.object.name;        //Now all we need to do is remove the dragged stim's object from the stimsWithLabelOnBoard List        //This will cause the label to be rerendered        if(stimId in stimsWithLabelOnBoard){            //remove it, to force a rerender           delete stimsWithLabelOnBoard[stimId];        }        //Fix UI bug, where user can abuse the render loop.        //This method checks to make sure there are no unattached labels        //Previously you could spam click the stim to ovrload therendering engine, in which case it creagted duplicates        //todo: there's probably a more elegant way to fix this issue, to replicate remove this line and spam click stims on the board        _clearUnAttachedLabels(stimId);    });    //Apply rotation locks    if(previewMode)        _applyControlLocks({            lockAll: true        });    //Fixed to withLocks not locks lol    else if(withLocks){        _applyControlLocks(withLocks)    }    // LIGHT    let ambLight = new THREE.AmbientLight(0xffffff);    ambLight.color.setHSL(0.6, 1, 0.6);    ambLight.position.set(0, 50, 0);    mBrdScene.add(ambLight);    let dirLight = new THREE.DirectionalLight(0xdfebff, 1);    dirLight.position.set(50, 200, 100);    dirLight.position.multiplyScalar(1.3);    mBrdScene.add(dirLight);    // SKYBOX/FOG    let skyBoxGeometry = new THREE.CubeGeometry(10000, 10000, 10000);    mSkyBoxMaterial = new THREE.MeshBasicMaterial({color: 0x000000, side: THREE.BackSide});    let skyBox = new THREE.Mesh(skyBoxGeometry, mSkyBoxMaterial);    mBrdScene.add(skyBox);    //Board Back    let board = new THREE.PlaneGeometry(24, 24);    mBrdMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, specular: 0x05050, ambientLight: 0x0, shininess: 30});    mBrdMesh = new THREE.Mesh(board, mBrdMaterial);    mBrdMesh.position.set(0, 0, -1);    mBrdMesh.rotation.y = Math.PI;    mBrdScene.add(mBrdMesh);    //Board Front    board = new THREE.PlaneGeometry(24, 24);    /*        Here is where we define what to put on the board fron        Some standard use cases: changing which image is rendered        changing from rendering an image, to rendering a base     */    mBrdMaterial = new THREE.MeshBasicMaterial({        color: 0xffffff, /*specular: 0x05050,*/        ambientLight: 0x0,        shininess: 30    });    //Just change the board material and rerender to  load image    mBrdMesh = new THREE.Mesh(board, mBrdMaterial);    mBrdMesh.position.set(0, 0, 0);    mBrdScene.add(mBrdMesh);     let boardTint = new THREE.PlaneGeometry(24, 24);    mBrdTintMaterial = new THREE.MeshBasicMaterial({        color: 0xffffff, /*specular: 0x05050,*/        ambientLight: 0x0,        shininess: 30    });    mBrdTintMesh = new THREE.Mesh(boardTint, mBrdTintMaterial);    mBrdTintMaterial.transparent = true;    mBrdTintMesh.position.set(0, 0, .5);    mBrdScene.add(mBrdTintMesh);    //Init to defaults here.    setBoardTintStrength(0);    setBoardTintRGB(0,0,0);    //Creates meshes on the sides of the board to make it look 3D    let BoardSideGeo = new THREE.PlaneGeometry(24, 1);    let BoardSideMat = new THREE.MeshPhongMaterial({color: 0xC0C0C0});    let BoardSide = new THREE.Mesh(BoardSideGeo, BoardSideMat);    BoardSide.position.set(0, 12, -0.5);    BoardSide.rotation.x = -Math.PI / 2;    mBrdScene.add(BoardSide);    BoardSide = new THREE.Mesh(BoardSideGeo, BoardSideMat);    BoardSide.rotation.x = -Math.PI / 2;    BoardSide.rotation.y = -Math.PI / 2;    BoardSide.position.set(-12, 0, -0.5);    mBrdScene.add(BoardSide);    BoardSide = new THREE.Mesh(BoardSideGeo, BoardSideMat);    BoardSide.rotation.x = -Math.PI / 2;    BoardSide.rotation.y = -Math.PI / 2 * 2;    BoardSide.position.set(0, -12, -0.5);    mBrdScene.add(BoardSide);    BoardSide= new THREE.Mesh(BoardSideGeo, BoardSideMat);    BoardSide.rotation.x = -Math.PI / 2;    BoardSide.rotation.y = -Math.PI / 2 * 3;    BoardSide.position.set(12, 0, -0.5);    mBrdScene.add(BoardSide);    //Begin rendering the board    _renderScene();    //Attach handlers    document.addEventListener('dblclick', ondblclick, false);    if(DEBUG_MODE){        //export for inspection        window.scene = mBrdScene;    }}//todo: deprecate this/** * @deprecated */function DEP_onDebug(){    let url = `${BASE_URL}/api/experiment/package/${EX_ID}`;    axios.get(url).then(        (request) =>{            if(request.data.items){                console.debug('Got items for experiment!');                initExperimentScene(true);                setBoard(request.data.items.board);                addStimsToBoard(request.data.items.stims);            }            else{                //todo: replace alert() calls with a better more user friendly way.                alert('Found no stims!');            }        }    ).catch(        (err) =>{            //todo: replace alerts            alert( `Failed to load debug package in preview widget. ${err}`);        }    )}/** * Doesn't care about true/false at the moment. Didn't want to lock it in to booleans, in the future we may want to specify range objects * So rightnow it just checks for the value of any lock key to not equal null. * todo: See line below. * You may want to tweak this method, so that it can be called more than once, for example, once enable there is no way to disable any lock. * For now, this falls outside of the scope but in the future it could have use. * */function _applyControlLocks(locks){    if(!locks){        console.warn('Invalid locks object was passed to _applyControlLocks');        return;    }    //Lock vertical tilt    if(locks.lockTilt || locks.lockAll) {        mBrdControl.minPolarAngle = Math.PI / 2;        mBrdControl.maxPolarAngle = Math.PI / 2;    }    //Lock vertical tilt    if(locks.lockZoom || locks.lockAll) {        mBrdControl.enableZoom = false    }    //lock horizontal rotation.    if(locks.lockRotate || locks.lockAll) {        mBrdControl.minAzimuthAngle = 0;        mBrdControl.maxAzimuthAngle = 0;    }}//I Still have no clue what this is doing?//Perhaps it locks the 'z' of the stims so that they cannot rais off the board/*    A common problem I encountered was that if the user tilts the board    sideways movement will change the z of the stim effectively, as you're moving the camera    so you could effectivly move a stim out of the board camera's FOV    This is bad, perhaps we could reimplement this method to keep all objects on the board at a set z */function boardLock() {    for (let i = 0; i < objects.length; i++) {        if (objects[i].position.y <= 12 && objects[i].position.y >= -12 && objects[i].position.x <= 12 && objects[i].position.x >= -12) {            objectOnBoard[i] = true;        }        if (stimsOnBoard[objects[i].name]) {            if (objects[i].position.x < -12) {                objects[i].position.x = -12;            }            if (objects[i].position.x > 12) {                objects[i].position.x = 12;            }            if (objects[i].position.y < -12) {                objects[i].position.y = -12;            }            if (objects[i].position.y > 12) {                objects[i].position.y = 12;            }            objects[i].position.z = 0.5;        }    }}//Render functions are ran each frame.function _renderLabels(){    stims = mBrdScene.children.forEach(        (sceneObject) => {            if(sceneObject.name){                //Check if the object is a stim                if(sceneObject.name in stimsOnBoard){                    //Render the label, if it has not already been rendered                    if(sceneObject.name in stimsWithLabelOnBoard){                        //Do nothing, if already renderedz                    }                    else{                        let labelText = stimsOnBoard[sceneObject.name].length > 0 ?                                stimsOnBoard[sceneObject.name] : sceneObject.name;                            //render the label for this stim                            //don't forget to attach the sceneObject name to the sprite                            //dont forget to update the label uidd datastructure                         let labelSprite = _makeTextSprite( labelText,                             { fontsize: 25, fontFamily: 'georgia'} );                         let stimPos = sceneObject.position;                         //Set the sprite to appear under the stim                        labelSprite.position.set(stimPos.x - 1.0,stimPos.y, stimPos.z);                        //don't forget to set the name                        labelSprite.name = sceneObject.name;                        //Store the UUID of the label in stims with label on board                        stimsWithLabelOnBoard[sceneObject.name] = labelSprite.uuid;                        //add label to scene                        mBrdScene.add(labelSprite);                    }                }            }        }    );    areLabelsShowing = true;}function _renderScene() {    requestAnimationFrame(_renderScene);    //mBrdControl.enabled = !lockBoard;    mBrdTintMaterial.opacity = mCurrentBrdTintStrength;    if(showLabels){        //Unlike with removing, we shouldalwaays rerender the labels, as they technically get deleted and redrawn on move.        _renderLabels();    }    else{        if(areLabelsShowing){            _clearAllLabels();        }    }    mBrdControl.update();    mBrdRenderer.render(mBrdScene, mBrdCamera);}/** * Removes all stim labels. */function _clearAllLabels(){    _onePassClearStimLabels();    _onePassClearStimLabels();    _onePassClearStimLabels();    _onePassClearStimLabels();    areLabelsShowing = false;}/*You may want to update this to also take a preview imageThis is so that you can bind the board with it's preview image contained in the exConfig! */function setBoard(board, config = null){    if(board.boardbackgroundurl){        let urls = board.boardbackgroundurl.split('>');        let url = useHttpsImage ? urls[0] : urls[1];        addBoardImage(url)    }    else{        setBoardRGB(board.boardr,board.boardg,board.boardb);    }    //Set background here    setBackgroundRGB(board.boardr,board.boardg,board.boardb);    if(config){        setBoardTintRGB(config.boardTintR, config.boardTintG, config.boardTintB);        setBoardTintStrength(config.boardTintOpacity);    }    renderedBoard = board; //    mBrdMesh.needsUpdate = true;}function toggleDraggableStims(on){    if(on){        mDragControls.activate();    }    else{        mDragControls.deactivate();    }}//updates the color of the backgroundfunction setBackgroundRGB(r,g,b) {    let redHex, blueHex, greenHex;    redHex = _rgbToHex(r);    greenHex = _rgbToHex(g);    blueHex = _rgbToHex(b);    let stringHex = "0x" + redHex + greenHex + blueHex;    mSkyBoxMaterial.color.setHex(stringHex);}function setBoardTintStrength(percent){    percent = percent / 100;    mCurrentBrdTintStrength = percent;}//updates the color of the backgroundfunction setBoardTintRGB(r,g,b) {    let redHex, blueHex, greenHex;    redHex = _rgbToHex(r);    greenHex = _rgbToHex(g);    blueHex = _rgbToHex(b);    let stringHex = "0x" + redHex + greenHex + blueHex;    mBrdTintMaterial.color.setHex(stringHex);}//updates the color of the boardfunction setBoardRGB(r,g,b) {    let redHex, blueHex, greenHex;    redHex = _rgbToHex(r);    greenHex = _rgbToHex(g);    blueHex = _rgbToHex(b);    let stringHex = "0x" + redHex + greenHex + blueHex;    mBrdMesh.material.color.setHex(stringHex);}function _clearUnAttachedLabels(stimId){    mBrdScene.children.forEach((sObject)=> {        if (sObject.hasOwnProperty('name') && sObject.name === stimId) {            //Check if the object a. belongs to the stim and b. Is actually a label            if (                sObject.name === stimId //If belongs to the stim                && sObject.uuid !== stimsWithLabelOnBoard[stimId]//If is not the attached label)                && sObject.uuid !== stimUuids[stimId]){ // and it's not the stim itself.){                    mBrdScene.remove(sObject);            }        }    });}function _clearLabelFromStim(stimId){    mBrdScene.children.forEach((sObject)=> {        if (sObject.hasOwnProperty('name') && sObject.name === stimId) {            //Check if the object a. belongs to the stim and b. Is actually a label            if (sObject.name === stimId && sObject.uuid === stimsWithLabelOnBoard[stimId]) {                mBrdScene.remove(sObject);            }        }    });}function toggleLabels(on){    showLabels = on;}/*    Adds a list of stim objects, see models.py, to the board scene */function addStimsToBoard(stimList){    PREVIEW_BUSY = true;    //There is reallyno reason to change this number, unless you want to start from the bottom.    let currentYOffset = -1;    //This number defines where each row will start    let currentXOffset = 1; //start at 1 to act as 'padding' ?    let stimPosInRow = 0;    stimList.forEach(        //for now just use a static offset x        (stim) =>{            addStimToBoard( null, stim, currentXOffset, currentYOffset);            stimPosInRow++;            currentXOffset += X_OFFSET; //Advance the column            if(stimPosInRow === MAX_STIMS_IN_ROW){                currentYOffset = currentYOffset - Y_OFFSET;                stimPosInRow = 0;                //Reset the x offset to the beginning of the row.                currentXOffset = 1;            }        }    )}/*hacky*///helper function that calls everything you need to clear boardfunction clearFullBoard(){    clearBoard();    clearBoard();    clearBoard();    clearBoard();    resetTrackers();}//Force clears the board, only removes a fraction of items for some reason...function clearBoard(){    mBrdScene.children.forEach(        (obj) =>{            if(obj.name in stimsOnBoard){                mBrdScene.remove(obj);            }            if(obj.uuid === stimsWithLabelOnBoard[obj.name]){                mBrdScene.remove(obj);            }        }    );}/*    used in a hacky way, to remove all the items from the board.    For some reason, when calling clear board once, only a fraction of the items are removed.    So we call it multiple times and just force all our tracking objects back to default state.    todo: maybe there is a better way to do this? */function resetTrackers(){    stimsOnBoard = {};    stimsWithLabelOnBoard = {};    objectOnBoard = [];    objects = [];}/*    More hacky    Still not sure why this doenst get them all in one go? It's almost as if it stops midway through.    todo: look into this glitch?    For now NEVER CALL THIS.    USE _clearAllLabels instead */function _onePassClearStimLabels(){    let stims = mBrdScene.children.forEach(        (sceneObject) => {            if(sceneObject.name){                if(sceneObject.name in stimsWithLabelOnBoard){                    //if this name is a valid stim id with a label                       if(sceneObject.uuid === stimsWithLabelOnBoard[sceneObject.name]){                           //if the uuid of the object matches here it means it is in fact the stim's label                           mBrdScene.remove(sceneObject); //remove label                           delete stimsWithLabelOnBoard[sceneObject.name]; //Remove as it should no longer have a label                       }                       else{                           //Do nothing, we don't care if is not the label                       }                    }            }        }    );}/* end hacky *//** * Adds an image to the board to be rendered. * Preview images should be rendered into a seperate layer 1 z above the base, todo: implement this later. * @param imageUrl * @param preview set this when using preview images so that it's treated as a preview */function addBoardImage(imageUrl, preview = false) {    /*    This next section is important, as it will check the constraint flags automatically for us.     */    if(preview){        if(!showPreviewImage){            console.warn('Cannot show preview, it has been disabled.');            return;        }    }    else{        if(!showBackground){            console.warn('Cannot show background image! it has been disabled.');            return;        }    }    renderingImage = true; //   mBrdMesh.material.map = THREE.ImageUtils.loadTexture(image);//    mBrdMesh.material.color.setHex("0xffffff");//    mBrdMesh.needsUpdate = true;    mBrdBackupMesh = mBrdMesh;    mBrdScene.remove(mBrdMesh);    //create new plane geometry    let board = new THREE.PlaneGeometry(24, 24);    //load the iamge as a texture, make sure to use the callbacks    let imgMaterial = new THREE.MeshLambertMaterial({        map: new THREE.TextureLoader().load(imageUrl, () => {            console.log('Loaded image texture')        }, ()=>{            console.log('Loading image texture')        },            (err) =>{            console.error('Failed Image Texture Load!');            if(err)                console.error('Was unable to load image texture ' + Object.keys(err))            })    });    //Just change the board material and rerender to  load image    mBrdMesh = new THREE.Mesh(board, imgMaterial);    mBrdMesh.position.set(0, 0, 0);    mBrdScene.add(mBrdMesh);}function addStimToBoard(disableButton, stim, offsetX = 0, offsetY = 0) {    let stimId, stimLabel, stimr, stimg, stimb, stimshape;    stimId = stim.stimid;    stimLabel = stim.stimlabel;    stimr = stim.stimr;    stimg = stim.stimg;    stimb = stim.stimb;    stimshape = stim.stimshape;    if(stimId && stimId in stimsOnBoard){        console.warn('Cannot add duplicate object!');        return;    }        $(disableButton).attr('disabled', true);        let peg, color, Pegmaterial, mesh, pegLabelSprite;        //create scene        let pegScene = new THREE.Scene();        if (stimshape === "Cube") {            peg = new THREE.CubeGeometry(1, 1, 1);            color = new THREE.Color("rgb(" + stimr + ", " + stimg + ", " + stimb + ")");            Pegmaterial = new THREE.MeshPhongMaterial({color: color, shininess: 50});            Pegmaterial.lights = true;            mesh = new THREE.Mesh(peg, Pegmaterial);        }        if (stimshape === "Cylinder") {            peg = new THREE.CylinderGeometry(0.5, 0.5, 1, 64);            color = new THREE.Color("rgb(" + stimr + ", " + stimg + ", " + stimb + ")");            Pegmaterial = new THREE.MeshPhongMaterial({color: color, shininess: 50});            Pegmaterial.lights = true;            mesh = new THREE.Mesh(peg, Pegmaterial);        }        if (stimshape === "Cone") {            peg = new THREE.CylinderGeometry(0, 0.5, 1, 64);            color = new THREE.Color("rgb(" + stimr + ", " + stimg + ", " + stimb + ")");            Pegmaterial = new THREE.MeshPhongMaterial({color: color, shininess: 50});            Pegmaterial.lights = true;            mesh = new THREE.Mesh(peg, Pegmaterial);        }        mesh.position.set(-12 + offsetX, 12 + offsetY, 3);        //Add to board        if(stimId) {            mesh.name = stimId;            //Add to registry            stimsOnBoard[mesh.name] = stimLabel;            stimUuids[mesh.name] = mesh.uuid;        }        //Toggle light interaction        //Add to scenes        pegScene.add( mesh );        objects.push( mesh );        mBrdScene.add( mesh );}function _makeTextSprite(message, parameters, anchorEl ) {    if ( parameters === undefined ) parameters = {};    let fontface = parameters.hasOwnProperty("fontface") ?                    parameters["fontface"] : "Arial";    let fontsize = parameters.hasOwnProperty("fontsize") ?    parameters["fontsize"] : 18;    let borderThickness = parameters.hasOwnProperty("borderThickness") ?    parameters["borderThickness"] : 4;    let backgroundColor = parameters.hasOwnProperty("backgroundColor") ?    parameters["backgroundColor"] : { r:255, g:255, b:255, a:0 };    let canvas = document.createElement('canvas');    context = canvas.getContext('2d');    context.font = "Bold " + fontsize + "px " + fontface;    // get size data (height depends only on font size)    let metrics = context.measureText( message );    let textWidth = metrics.width;    // text color    context.fillStyle = "rgba(255, 255, 255, 1.0)";    context.fillText( message, borderThickness, fontsize + borderThickness);    // canvas contents will be used for a texture    let texture = new THREE.Texture(canvas);    texture.needsUpdate = true;    // useScreenCoordinates is not a property of this material    spriteMaterial = new THREE.SpriteMaterial( { map: texture } );    spriteMaterial.blending = THREE.NormalBlending;    spriteMaterial.color.setHex("0x000000");    let sprite = new THREE.Sprite( spriteMaterial );    sprite.scale.set(10,10,1.0);    sprite.center.set(0,1);    sprite.width = textWidth;    return sprite;}function showBackgroundImage(image_url){}function _rgbToHex(rgb) {    let hex = Number(rgb).toString(16);    if (hex.length < 2) {        hex = "0" + hex;    }    return hex;}function revertCamera() {    let brdCam = mBrdCamera;    brdCam.position = mBrdCamera.position.set(0, 0, 400);    brdCam.lookAt(mBrdScene.position);    mBrdCamera = brdCam;}